// Code generated by Zipline. DO NOT EDIT.

//go:build !ziplinegen
// +build !ziplinegen

package web

import (
	"encoding/json"
	"io"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/bilal-bhatti/zipline/example/connectors"
	"github.com/bilal-bhatti/zipline/example/models"
	"github.com/bilal-bhatti/zipline/example/render"
	"github.com/bilal-bhatti/zipline/example/services"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

// NewRouter returns a router configured with endpoints and handlers.
//
// @swagger                    2.0
// @info.title                 Example OpenAPI Version 2 Specification
// @info.version               1.0.0
// @info.description           Example OpenAPI Version 2 Specification
// @info.termsOfService        http://swagger.io/terms/
// @info.contact.name          API Support
// @info.contact.url           http://www.swagger.io/support
// @info.contact.email         support@swagger.io
//
//	@info.license               {
//	 "name": "Apache 2.0",
//	 "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
//	}
//
// @schemes                    ["http", "https"]
// @host                       api.example.com
// @basePath                   /api
// @consumes                   application/json
// @produces                   application/json
// @produces                   application/text
//
//	@securityDefinitions.token  {
//	 "description": "Requests should pass a token.",
//	 "type": "token",
//	 "name": "X-TOKEN",
//	 "in": "header"
//	}
//
// @security                   [{"token": []}]
// @externalDocs.description   OpenAPI
// @externalDocs.url           https://swagger.io/resources/open-api/
//
// summary          Get a list of contacts by ids
// description      Get a list of contacts by ids
// tags              contacts
// produces         application/json
// parameters        (name:ids, description: list of contact ids, required:true)
// parameters        {"name": "foo", "description": "foo description", "required": false}
// responses.400     {models.ErrorResponse}
// responses.404     {models.ErrorResponse}
// responses.default {models.ErrorResponse}
func NewRouter(env *connectors.Env) *chi.Mux {
	mux := chi.NewRouter()
	mux.Use(services.Authentication)

	mux.Post("/contacts", ContactsServiceCreateHandlerFunc(env))

	mux.Get("/contacts/{id}", ContactsServiceGetOneHandlerFunc())
	mux.Get("/contacts", ContactsServiceGetBunchHandlerFunc())
	mux.Get("/contacts/{month}-{day}-{year}", ContactsServiceGetByDateHandlerFunc())
	mux.Post("/contacts/{id}", ContactsServiceUpdateHandlerFunc(env))
	mux.Put("/contacts/{id}", ContactsServiceReplaceHandlerFunc())
	mux.Delete("/contacts", ContactsServiceDeleteBulkHandlerFunc())

	mux.Post("/things", ThingsServiceCreateHandlerFunc())
	mux.Get("/things/{category}", ThingsServiceGetByCategoryAndQueryHandlerFunc())
	mux.Get("/things", ThingsServiceGetByDateRangeHandlerFunc())
	mux.Delete("/things/{id}", ThingsServiceDeleteHandlerFunc())

	mux.Get("/echo/{input}", EchoHandlerFunc(env))

	mux.Post("/doodads", DoodadsServiceCreateHandlerFunc(env))

	mux.Post("/ping", PingHandlerFunc(env))

	return mux
}

// ContactsServiceCreateHandlerFunc handles requests to:
// path  : /contacts
// method: post
// Create a new contact request entity.
func ContactsServiceCreateHandlerFunc(env *connectors.Env) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [contactRequest] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		contactRequest := &services.ContactRequest{}
		err = json.NewDecoder(r.Body).Decode(contactRequest)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := handler.Create(ctx, contactRequest)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceGetOneHandlerFunc handles requests to:
// path  : /contacts/{id}
// method: get
// GetOne contact by id
// @id contact id
func ContactsServiceGetOneHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [id] with [Path] template
		id, err := strconv.Atoi(chi.URLParam(r, "id"))
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// execute application handler
		response, err := handler.GetOne(ctx, id)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceGetBunchHandlerFunc handles requests to:
// path  : /contacts
// method: get
// GetBunch of contacts by ids
// @summary           Get a list of contacts by ids
// @description       Get a list of contacts by ids
// @tags              contacts
// @produces          application/json
// @parameters        (name:ids, description: list of contact ids, required:true)
// @responses.400     {models.ErrorResponse}
// @responses.404     {models.ErrorResponse}
// @responses.default {models.ErrorResponse}
func ContactsServiceGetBunchHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [ids] with [Query] template
		ids, err := ParseInt64(r.URL.Query()["ids"])
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// execute application handler
		response, err := handler.GetBunch(ctx, ids)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceGetByDateHandlerFunc handles requests to:
// path  : /contacts/{month}-{day}-{year}
// method: get
// Get contacts list by date
func ContactsServiceGetByDateHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [month] with [Path] template
		month := chi.URLParam(r, "month")

		// resolve parameter [day] with [Path] template
		day := chi.URLParam(r, "day")

		// resolve parameter [year] with [Path] template
		year := chi.URLParam(r, "year")

		// execute application handler
		response, err := handler.GetByDate(ctx, month, day, year)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceUpdateHandlerFunc handles requests to:
// path  : /contacts/{id}
// method: post
// Update a contact entity with provided data.
func ContactsServiceUpdateHandlerFunc(env *connectors.Env) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [id] with [Path] template
		id, err := strconv.Atoi(chi.URLParam(r, "id"))
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// resolve parameter [contactRequest] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		contactRequest := services.ContactRequest{}
		err = json.NewDecoder(r.Body).Decode(&contactRequest)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := handler.Update(ctx, id, contactRequest)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceReplaceHandlerFunc handles requests to:
// path  : /contacts/{id}
// method: put
// Replace a contact entity completely.
func ContactsServiceReplaceHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [id] with [Path] template
		id, err := strconv.Atoi(chi.URLParam(r, "id"))
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// resolve parameter [contactRequest] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		contactRequest := services.ContactRequest{}
		err = json.NewDecoder(r.Body).Decode(&contactRequest)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := handler.Replace(ctx, id, contactRequest)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ContactsServiceDeleteBulkHandlerFunc handles requests to:
// path  : /contacts
// method: delete
// DeleteBulk contact by id
func ContactsServiceDeleteBulkHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.InitContactsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [ids] with [Query] template
		ids := r.URL.Query()["ids"]

		// execute application handler
		err = handler.DeleteBulk(ctx, ids)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		w.WriteHeader(http.StatusNoContent)
	}
}

// ThingsServiceCreateHandlerFunc handles requests to:
// path  : /things
// method: post
// Create thing
func ThingsServiceCreateHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := InitThingsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [req] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		req := models.ThingRequest{}
		err = json.NewDecoder(r.Body).Decode(&req)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := handler.Create(ctx, req)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ThingsServiceGetByCategoryAndQueryHandlerFunc handles requests to:
// path  : /things/{category}
// method: get
// Get things by category and search query
// @category category of data to search
// @q search query
func ThingsServiceGetByCategoryAndQueryHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := InitThingsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [category] with [Path] template
		category := chi.URLParam(r, "category")

		// resolve parameter [q] with [Query] template
		q := r.URL.Query().Get("q")

		// execute application handler
		response, err := handler.GetByCategoryAndQuery(ctx, category, q)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ThingsServiceGetByDateRangeHandlerFunc handles requests to:
// path  : /things
// method: get
// Get things by date range
// @from `format:"date-time,2006-01-02"` date should be in Go time format
// @to   `format:"date-time,2006-01-02"` date should be in Go time format
func ThingsServiceGetByDateRangeHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := InitThingsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [from] with [Query] template
		from, err := ParseTime(r.URL.Query().Get("from"), "date-time,2006-01-02")
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// resolve parameter [to] with [Query] template
		to, err := ParseTime(r.URL.Query().Get("to"), "date-time,2006-01-02")
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// execute application handler
		response, err := handler.GetByDateRange(ctx, from, to)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// ThingsServiceDeleteHandlerFunc handles requests to:
// path  : /things/{id}
// method: delete
// Delete thing by id
func ThingsServiceDeleteHandlerFunc() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := InitThingsService()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [id] with [Path] template
		id, err := strconv.Atoi(chi.URLParam(r, "id"))
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse parameter"))
			return
		}

		// execute application handler
		err = handler.Delete(id)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		w.WriteHeader(http.StatusNoContent)
	}
}

// EchoHandlerFunc handles requests to:
// path  : /echo/{input}
// method: get
// Echo returns body with 'i's replaced with 'o's
func EchoHandlerFunc(env *connectors.Env) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [input] with [Path] template
		input := chi.URLParam(r, "input")

		// execute application handler
		response, err := Echo(ctx, input)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// DoodadsServiceCreateHandlerFunc handles requests to:
// path  : /doodads
// method: post
// Create a new doodad entity.
func DoodadsServiceCreateHandlerFunc(env *connectors.Env) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()

		// initialize application handler
		handler, err := services.NewDoodadsService(env)
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [url] through a provider
		url := services.ProvideForwardedHeader(r)

		// resolve parameter [thing] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		thing := &models.ThingRequest{}
		err = json.NewDecoder(r.Body).Decode(thing)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := handler.Create(ctx, url, r, thing)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}

// PingHandlerFunc handles requests to:
// path  : /ping
// method: post
// Ping returns body with 'i's replaced with 'o's
func PingHandlerFunc(env *connectors.Env) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var err error
		startTime := time.Now()
		defer func() {
			duration := time.Now().Sub(startTime)
			log.Printf("It took %s to process request\n", duration.String())
		}()
		if err != nil {
			render.Error(w, errors.Wrap(err, "failed to resolve application handler"))
			return
		}

		// resolve parameter [ctx] through a provider
		ctx := services.ProvideContext(r)

		// resolve parameter [pingRequest] with [Body] template
		defer io.Copy(io.Discard, r.Body)
		pingRequest := services.PingRequest{}
		err = json.NewDecoder(r.Body).Decode(&pingRequest)
		if err != nil {
			render.Error(w, render.WrapBadRequestError(err, "failed to parse request body"))
			return
		}

		// execute application handler
		response, err := services.Ping(ctx, env, pingRequest)
		if err != nil {
			render.Error(w, errors.Wrap(err, "application handler failed"))
			return
		}
		render.Response(w, response)
	}
}
