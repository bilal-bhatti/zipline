package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"strings"
)

var (
	hreq = varToken{name: "req", signature: "*net/http.Request"}
	hwri = varToken{name: "w", signature: "net/http.ResponseWriter"}
)

type renderer struct {
	provider *provider
	imps     []string
	types    []string
	preamble *bytes.Buffer
	body     *bytes.Buffer
}

func (r *renderer) imp(imp string) {
	if imp != "" {
		r.imps = append(r.imps, "\""+imp+"\"")
	}
}

func newRenderer(provider *provider) *renderer {
	r := &renderer{
		provider: provider,
		imps:     make([]string, 0),
		types:    make([]string, 0),
		preamble: &bytes.Buffer{},
		body:     &bytes.Buffer{},
	}

	return r
}

func (r *renderer) render(info *binding) {
	switch info.method {
	case "Post":
		r.post(info)
	case "Get":
		r.get(info)
	}
}

func (r *renderer) ws(s string, vals ...interface{}) {
	if len(vals) > 0 {
		r.body.WriteString(fmt.Sprintf(s, vals...))
	} else {
		r.body.WriteString(s)
	}
}

func (r *renderer) pre(s string, vals ...interface{}) {
	if len(vals) > 0 {
		r.preamble.WriteString(fmt.Sprintf(s, vals...))
	} else {
		r.preamble.WriteString(s)
	}
}

func pkgName(packet *packet) string {
	pkn := packet.pkg.Name
	idx := strings.LastIndex(pkn, "/")
	if idx > 0 {
		pkn = pkn[:len(pkn)]
		return pkn
	}
	return pkn
}

func (r *renderer) complete(packet *packet) {
	r.pre("// Code generated by Zipline. DO NOT EDIT.\n\n")

	r.pre("// go:generate zipline\n")
	r.pre("// +build !ziplinegen\n\n")

	// write package name
	r.pre("package %s\n\n", pkgName(packet))

	// write imports
	r.pre("import (\n%s)\n\n", strings.Join(r.imps, "\n"))

	// write handler types
	r.pre("type (\n%s\n)\n\n", strings.Join(r.types, "\n"))

	// write binding func
	fset := token.NewFileSet()
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, packet.bindings)
	r.pre("\n\n")
	r.preamble.Write(buf.Bytes())
	r.pre("\n\n")

	// write generated handler funcs
	r.preamble.Write(r.body.Bytes())
}

func (r *renderer) print(w io.Writer, frmt bool) {
	if frmt {
		formatted, err := format.Source(r.preamble.Bytes())
		if err != nil {
			panic(err)
		}
		w.Write(formatted)
	} else {
		w.Write(r.preamble.Bytes())
	}
}

func (r *renderer) post(binding *binding) {
	r.imp(hreq.pkg())

	r.recordFuncType(binding)
	r.ws("func %sHandlerFunc(funk %sType) http.HandlerFunc {\n", binding.id(), binding.id())
	r.ws("return func(%s %s, %s %s) {\n", hwri.varName(), hwri.param(), hreq.varName(), hreq.param())
	r.ws("var err error // tempory fix\n\n")

	params := []string{}
	for _, p := range binding.handler.params {
		ft := r.provider.provide(p)
		if ft != nil {
			r.writeProvider(p, ft)
			r.imp(ft.pkg())
		} else if pathParam(binding, p) {
			r.writePathParam(p)
		} else {
			r.writeJSONDecoder(p)
		}

		params = append(params, p.varName())

		r.imp(p.pkg())

		r.ws("\n")
	}

	r.ws("result, err := funk(%s)\n", strings.Join(params, ","))

	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  // internal error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")

	r.ws("%s.WriteHeader(http.StatusOK)\n", hwri.varName())
	r.ws("%s.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n", hwri.varName())

	r.ws("err = json.NewEncoder(%s).Encode(result)\n", hwri.varName())
	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  panic(err)\n")
	r.ws("}\n")

	r.ws("}\n")
	r.ws("}\n\n")
}

func (r *renderer) get(binding *binding) {
	r.imp(hreq.pkg())

	r.recordFuncType(binding)
	r.ws("func %sHandlerFunc(funk %sType) http.HandlerFunc {\n", binding.id(), binding.id())
	r.ws("return func(%s %s, %s %s) {\n", hwri.varName(), hwri.param(), hreq.varName(), hreq.param())
	r.ws("var err error // tempory fix\n\n")

	params := []string{}
	for _, p := range binding.handler.params {
		ft := r.provider.provide(p)
		if ft != nil {
			r.writeProvider(p, ft)
			r.imp(ft.pkg())
		} else if pathParam(binding, p) {
			r.writePathParam(p)
		}

		params = append(params, p.varName())
		r.imp(p.pkg())

		r.ws("\n")
	}

	r.ws("result, err := funk(%s)\n", strings.Join(params, ","))

	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  // internal error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")

	r.ws("%s.WriteHeader(http.StatusOK)\n", hwri.varName())
	r.ws("%s.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n", hwri.varName())

	r.ws("err = json.NewEncoder(%s).Encode(result)\n", hwri.varName())
	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  panic(err)\n")
	r.ws("}\n")

	r.ws("}\n")
	r.ws("}\n\n")
}

func (r *renderer) writeProvider(p *varToken, ft *funcToken) {
	r.ws("%s := %s\n", p.varName(), ft.call(hreq.varName()))
}

func (r *renderer) writePathParam(p *varToken) {
	r.ws("%s, err := strconv.Atoi(chi.URLParam(%s, \"%s\"))\n", p.name, hreq.varName(), p.name)
	r.ws("if err != nil {\n")
	r.ws("  // invalid request error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")
}

func (r *renderer) writeJSONDecoder(p *varToken) {
	r.ws("%s := %s\n", p.varName(), p.inst())
	r.ws("err = json.NewDecoder(req.Body).Decode(%s)\n", p.varNameAsPointer())
	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  // invalid request error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")
}

func (r *renderer) recordFuncType(b *binding) {
	tipe := fmt.Sprintf("%sType func(%s) (%s)", b.id(), join(b.handler.params), join(b.handler.returns))
	r.types = append(r.types, tipe)
}

func join(tokens []*varToken) string {
	s := []string{}
	for _, token := range tokens {
		s = append(s, token.param())
	}

	return strings.Join(s, ",")
}
