package internal

import (
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"log"
	"strings"

	"github.com/go-toolsmith/astcopy"
	"golang.org/x/tools/go/packages"
)

type renderer struct {
	templates map[string]*template
	provider  *provider
	imps      []string
	preamble  *buffer
	body      *buffer
}

func (r *renderer) imp(imp string) {
	if imp != "" {
		r.imps = append(r.imps, "\""+imp+"\"")
	}
}

func newRenderer(templates map[string]*template, provider *provider) *renderer {
	r := &renderer{
		templates: templates,
		provider:  provider,
		imps:      make([]string, 0),
		preamble:  newBuffer(),
		body:      newBuffer(),
	}

	return r
}

func (r *renderer) render(pkg *packages.Package, info *binding) error {
	for _, bp := range info.boundParams {
		r.provider.known[bp.signature] = bp
	}

	template := r.templates[info.template]
	if template != nil {
		bites, err := r.renderFunctionTemplate(pkg, template, info)
		if err != nil {
			return err
		}
		r.body.add(bites)
	} else {
		return errors.New(fmt.Sprintf("template not found for %s", info.template))
	}
	return nil
}

func pkgName(packet *packet) string {
	pkn := packet.pkg.Name
	idx := strings.LastIndex(pkn, "/")
	if idx > 0 {
		pkn = pkn[:len(pkn)]
		return pkn
	}
	return pkn
}

func (r *renderer) complete(packet *packet) {
	r.preamble.ws("// Code generated by Zipline. DO NOT EDIT.\n\n")
	// r.preamble.ws("//go:generate zipline\n")
	r.preamble.ws("//+build !ziplinegen\n\n")

	// write package name
	r.preamble.ws("package %s\n\n", pkgName(packet))

	// write imports
	r.preamble.ws("import (\n%s)\n\n", strings.Join(r.imps, "\n"))

	// write binding func
	buf := newBuffer()
	printer.Fprint(buf.buf, packet.pkg.Fset, packet.funcDecl)
	r.preamble.ws("\n\n")
	r.preamble.add(buf)
	r.preamble.ws("\n\n")

	// write generated handler funcs
	r.preamble.add(r.body)
}

func (r *renderer) print(w io.Writer, frmt bool) error {
	if frmt {
		formatted, err := format.Source(r.preamble.buf.Bytes())
		if err != nil {
			return err
		}
		w.Write(formatted)
	} else {
		w.Write(r.preamble.buf.Bytes())
	}

	return nil
}

func (r *renderer) renderFunctionTemplate(pkg *packages.Package, t *template, b *binding) (*buffer, error) {
	buf := newBuffer()

	for _, stmt := range t.funcDecl.Body.List {
		// must be a return statement
		ret := stmt.(*ast.ReturnStmt)

		funclit := ret.Results[0].(*ast.FuncLit)
		// parse funclit type to extract type tokens
		for _, param := range funclit.Type.Params.List {
			for _, pn := range param.Names {
				obj := r.provider.qualifiedIdentObject(pn)
				tt := newTypeToken("", obj.Type().String(), obj.Name())
				r.provider.known[tt.signature] = tt
			}
		}

		buf.ws("// %s%s handles requests to:\n", b.id(), t.funcSuffix())
		buf.ws("// path  : %s\n", b.path)
		buf.ws("// method: %s\n", strings.ToLower(b.template))
		for _, c := range b.handler.comments.raw {
			buf.ws("// %s\n", c)
		}

		buf.ws("func %s%s(%s) %s {\n", b.id(), t.funcSuffix(), b.boundParamsList(), t.returnType())
		buf.ws("return ")
		printer.Fprint(buf.buf, pkg.Fset, funclit.Type)
		buf.ws(" {\n")

		for _, fstmt := range funclit.Body.List {
			if r.devNull(fstmt) {
				// omit
				continue
			}

			assnStmt, ok := fstmt.(*ast.AssignStmt)
			if !ok || len(assnStmt.Rhs) != 1 {
				goto Include
			}

			if call, ok := assnStmt.Rhs[0].(*ast.CallExpr); ok {
				if selector, ok := call.Fun.(*ast.SelectorExpr); ok {
					obj := r.provider.qualifiedIdentObject(selector.X)
					if obj != nil && strings.HasSuffix(obj.Type().String(), ZiplineTemplate) {
						if selector.Sel.String() == ZiplineTemplateResolve {
							if err := r.resolve(pkg, b, assnStmt, buf); err != nil {
								return nil, err
							}
						} else {
							if err := r.expand(pkg, b, assnStmt, buf); err != nil {
								return nil, err
							}
						}

						continue
					}
				}
			}

			// assignment statement, let's record any var assignments
			for _, lhs := range assnStmt.Lhs {
				if id, ok := lhs.(*ast.Ident); ok {
					obj := r.provider.qualifiedIdentObject(id)

					// this will keep the later declarations
					tt := newTypeToken("", obj.Type().String(), obj.Name())
					r.provider.known[tt.signature] = tt
				}
			}

		Include:
			printer.Fprint(buf.buf, pkg.Fset, fstmt)
			buf.ws("\n")
		}

		buf.ws("}\n")
		buf.ws("}\n\n")
	}

	return buf, nil
}

func (r *renderer) resolve(pkg *packages.Package, b *binding, assn *ast.AssignStmt, buf *buffer) error {
	// resolve/print handler
	if b.handler.x != nil {
		rets := []string{}
		// extract return names from the marker call
		for _, lhs := range assn.Lhs {
			rets = append(rets, lhs.(*ast.Ident).String())
		}

		xp, err := r.provider.provideWithReturns(b.handler.x, rets)
		if err != nil {
			log.Println("rets", rets)
			return newHandlerNotResolvedError(err.Error(), b, rets)
		}
		buf.ws("\n// initialize application handler\n")
		buf.ws(xp.call(pkg.PkgPath) + "\n")
		r.imp(xp.pkg())
	}

	return nil
}

func (r *renderer) expand(pkg *packages.Package, b *binding, assn *ast.AssignStmt, buf *buffer) error {
	// resolve/print app handler dependencies and retain their var names
	params, err := r.deps(pkg, b, buf)
	if err != nil {
		return err
	}

	rets := []string{}
	// extract return names from the marker call
	for _, lhs := range assn.Lhs {
		rets = append(rets, lhs.(*ast.Ident).String())
	}

	buf.ws("// execute application handler\n")

	buf.ws(strings.Join(rets, ","))
	buf.ws(" %s ", assn.Tok.String())

	if b.handler.x != nil {
		// a struct method is the handler
		funk, ok := r.provider.typeTokenFor(b.handler.x)
		if !ok {
			return errors.New("dependencies not satisfied")
		}

		buf.ws("%s.", funk.varName())
	}

	buf.ws("%s(%s)\n", b.handler.sel, strings.Join(params, ","))

	return nil
}

func (r *renderer) deps(pkg *packages.Package, b *binding, buf *buffer) ([]string, error) {
	params := []string{}

	for i := 0; i < len(b.handler.params); i++ {
		p := b.handler.params[i]

		if len(b.paramTemplates) > i {
			tn := b.paramTemplates[i]
			template := r.templates[tn]
			trace("using template %s for type %s\n", tn, p.signature)
			if template != nil {
				buf.ws("\n// resolve parameter [%s] with [%s] template\n", p.varName(), tn)
				switch tn {
				case "Query", "Path":
					err := r.renderParamTemplate(pkg, template, b, p, buf)
					if err != nil {
						return nil, err
					}
				case "Body":
					err := r.renderBodyTemplate(pkg, template, b, p, buf)
					if err != nil {
						return nil, err
					}
				default:
					err := r.renderGenericTemplate(pkg, template, b, p, buf)
					if err != nil {
						return nil, err
					}
				}

				params = append(params, p.varName())
				buf.ws("\n")
				continue
			}

			if tn == ZiplineTemplateResolve {
				ft, err := r.provider.provideWithReturns(p, []string{p.name})
				if err != nil {
					return nil, newParameterProviderError("failed to resolve handler parameters", b, p)
				}

				buf.ws("\n// resolve parameter [%s] through a provider\n", p.varName())
				buf.ws(ft.call(pkg.PkgPath) + "\n")

				params = append(params, p.varName())
				continue
			}
		}

		// faild to find a way to satisfy parameter
		return nil, newParameterError("failed to resolve handler parameters", b, p)
	}

	return params, nil
}

func (r *renderer) renderParamTemplate(pkg *packages.Package, t *template, b *binding, p *typeToken, buf *buffer) error {
	var tmplBody []ast.Stmt

	if len(t.funcDecl.Body.List) != 1 {
		return errors.New(fmt.Sprintf("template %s must contain a single switch statement", t.funcDecl.Name))
	}

	switchStmt, ok := t.funcDecl.Body.List[0].(*ast.SwitchStmt)
	if !ok {
		return errors.New(fmt.Sprintf("template %s must contain a single switch statement", t.funcDecl.Name))
	}

	for _, sb := range switchStmt.Body.List {
		caseStmt, ok := sb.(*ast.CaseClause)
		if !ok {
			return errors.New(fmt.Sprintf("template %s must contain a signle switch statement", t.funcDecl.Name))
		}

		for _, csl := range caseStmt.List {
			blit, ok := csl.(*ast.BasicLit)
			if !ok {
				continue
			}

			if blit.Value == fmt.Sprintf("\"%s\"", p.fullSignature()) {
				tmplBody = caseStmt.Body
				break
			}
		}
	}

	if tmplBody == nil {
		return newParameterTemplateError("failed to locate request parameters", t, b, p)
	}

	var format string
	tags, ok := b.handler.comments.tags[p.varName()]
	if ok {
		tag, err := tags.Get("format")
		if err == nil {
			format = fmt.Sprintf("%s,%s", tag.Name, strings.Join(tag.Options, ","))
		}
	}

	tbuf := r.rename("name", format, p, tmplBody)
	buf.add(tbuf)

	return nil
}

func (r *renderer) renderBodyTemplate(pkg *packages.Package, t *template, b *binding, p *typeToken, buf *buffer) error {
	return r.renderGenericTemplate(pkg, t, b, p, buf)
}

func (r *renderer) renderGenericTemplate(pkg *packages.Package, t *template, b *binding, p *typeToken, buf *buffer) error {
	tbuf := r.rename("name", "", p, t.funcDecl.Body.List)
	buf.add(tbuf)
	return nil
}

func (r *renderer) rename(old, format string, new *typeToken, body []ast.Stmt) *buffer {
	renamer := func(n ast.Node) bool {
		switch nt := n.(type) {
		case *ast.BasicLit:
			if nt.Value == fmt.Sprintf("\"%s\"", old) {
				nt.Value = fmt.Sprintf("\"%s\"", new.name)
			}
			if format != "" && nt.Value == fmt.Sprintf("\"format\"") {
				nt.Value = fmt.Sprintf("\"%s\"", format)
			}
		case *ast.Ident:
			if nt.Name == old {
				nt.Name = new.name
			}
		case *ast.CallExpr:
			for i := 0; i < len(nt.Args); i++ {
				arg := nt.Args[i]
				ue, ok := arg.(*ast.UnaryExpr)
				if !ok {
					return true
				}

				id, ok := ue.X.(*ast.Ident)
				if !ok {
					return true
				}

				if id.Name == old {
					if new.isPtr {
						// param was declared as a pointer
						// replace unary expression with ident
						nt.Args[i] = ast.NewIdent(new.name)
					}
				}
			}
		}

		return true
	}

	buf := newBuffer()

	for _, stmt := range body {
		sc := astcopy.Stmt(stmt)

		switch st := stmt.(type) {
		case *ast.DeclStmt:
			// omit printing var decls that are repeated
			gd, ok := st.Decl.(*ast.GenDecl)
			if !ok {
				goto Include
			}

			// only if a single var declaration
			if gd.Tok != token.VAR || len(gd.Specs) != 1 {
				goto Include
			}

			vs, ok := gd.Specs[0].(*ast.ValueSpec)
			if !ok || len(vs.Names) != 1 {
				goto Include
			}

			if id, ok := vs.Type.(*ast.Ident); ok {
				v, ok := r.provider.known[id.Name]
				// omit if known var with same name
				if ok && v.name == vs.Names[0].String() {
					continue
				}
			}
		case *ast.AssignStmt:
			if r.newStructValue(st) {
				// get new object
				buf.ws("%s := %s\n", new.varName(), new.inst())
				continue
			}
			ast.Inspect(sc, renamer)
		case *ast.ExprStmt:
			// filter out zipline directive
			if r.devNull(st) {
				continue
			}
			ast.Inspect(sc, renamer)
		default:
			ast.Inspect(sc, renamer)
		}
	Include:
		printer.Fprint(buf.buf, token.NewFileSet(), sc)
		buf.ws("\n")
	}

	return buf
}

func (r *renderer) devNull(stmt ast.Stmt) bool {
	expr, ok := stmt.(*ast.ExprStmt)
	if !ok {
		return false
	}

	call, ok := expr.X.(*ast.CallExpr)
	if !ok {
		return false
	}

	if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
		zobj := r.provider.qualifiedIdentObject(sel.X)
		if zobj != nil && strings.HasSuffix(zobj.Type().String(), ZiplineTemplate) {
			// if ignore
			if sel.Sel.Name == ZiplineTemplateDevNull || sel.Sel.Name == ZiplineTemplateIgnore {
				return true
			}
		}
	}

	return false
}

func (r *renderer) newStructValue(expr *ast.AssignStmt) bool {
	// check if it's a new ZiplineTemplate object
	// must be a simple assignment like
	// name := ZiplineTemplate{} or name := &ZiplineTemplate{}
	if len(expr.Lhs) != 1 && len(expr.Rhs) != 1 {
		return false
	}

	var newObj *ast.CompositeLit

	if unary, ok := expr.Rhs[0].(*ast.UnaryExpr); ok {
		newObj, ok = unary.X.(*ast.CompositeLit)
		if !ok {
			return false
		}
	} else {
		newObj, ok = expr.Rhs[0].(*ast.CompositeLit)
		if !ok {
			return false
		}
	}

	valueType, ok := newObj.Type.(*ast.Ident)
	if !ok || valueType.Name != ZiplineTemplate {
		return false
	}

	return true
}

// func join(tokens []*typeToken) string {
// 	s := []string{}
// 	for _, token := range tokens {
// 		s = append(s, token.param())
// 	}

// 	return strings.Join(s, ",")
// }

func join(tokens []*typeToken, f func(token *typeToken) string) string {
	s := []string{}
	for _, token := range tokens {
		s = append(s, f(token))
	}

	return strings.Join(s, ",")
}
