package internal

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"strings"
)

var (
	HREQ  = newVarToken("", "*net/http.Request", "request")
	HWRI  = newVarToken("", "net/http.ResponseWriter", "responseWriter")
	ERROR = newVarToken("", "error", "err")
)

type renderer struct {
	templates map[string]*template
	provider  *provider
	imps      []string
	preamble  buffer
	body      buffer
}

func (r *renderer) imp(imp string) {
	if imp != "" {
		r.imps = append(r.imps, "\""+imp+"\"")
	}
}

func newRenderer(templates map[string]*template, provider *provider) *renderer {
	r := &renderer{
		templates: templates,
		provider:  provider,
		imps:      make([]string, 0),
		preamble:  newBuffer(),
		body:      newBuffer(),
	}

	return r
}

func (r *renderer) render(info *binding) {
	template := r.templates[info.method]
	if template != nil {
		bites, err := r.renderTemplate(template, info)
		if err != nil {
			panic(err)
		}
		r.body.buf.Write(bites)
	}
}

func pkgName(packet *packet) string {
	pkn := packet.pkg.Name
	idx := strings.LastIndex(pkn, "/")
	if idx > 0 {
		pkn = pkn[:len(pkn)]
		return pkn
	}
	return pkn
}

func (r *renderer) complete(packet *packet) {
	r.preamble.ws("// Code generated by Zipline. DO NOT EDIT.\n\n")

	r.preamble.ws("// go:generate zipline\n")
	r.preamble.ws("// +build !ziplinegen\n\n")

	// write package name
	r.preamble.ws("package %s\n\n", pkgName(packet))

	// write imports
	r.preamble.ws("import (\n%s)\n\n", strings.Join(r.imps, "\n"))

	// write binding func
	fset := token.NewFileSet()
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, packet.bindings)
	r.preamble.ws("\n\n")
	r.preamble.buf.Write(buf.Bytes())
	r.preamble.ws("\n\n")

	// write generated handler funcs
	r.preamble.buf.Write(r.body.buf.Bytes())
}

func (r *renderer) print(w io.Writer, frmt bool) {
	if frmt {
		formatted, err := format.Source(r.preamble.buf.Bytes())
		if err != nil {
			panic(err)
		}
		w.Write(formatted)
	} else {
		w.Write(r.preamble.buf.Bytes())
	}
}

func (r *renderer) renderTemplate(t *template, b *binding) ([]byte, error) {
	fset := token.NewFileSet()

	buf := newBuffer()

	for _, stmt := range t.funcDecl.Body.List {
		// must be a return statement
		ret := stmt.(*ast.ReturnStmt)

		funclit := ret.Results[0].(*ast.FuncLit)
		buf.ws("// %s%s handles requests to:\n", b.id(), t.funcSuffix())
		buf.ws("// path  : %s\n", b.path)
		buf.ws("// method: %s\n", b.method)
		buf.ws("func %s%s() %s {\n", b.id(), t.funcSuffix(), t.returnType())
		buf.ws("return ")
		printer.Fprint(buf.buf, fset, funclit.Type)
		buf.ws(" {\n")

		for _, fstmt := range funclit.Body.List {
			var expand = false

			switch stmtType := fstmt.(type) {
			case *ast.AssignStmt:
				if call, ok := stmtType.Rhs[0].(*ast.CallExpr); ok {
					if selector, ok := call.Fun.(*ast.SelectorExpr); ok {
						obj := r.provider.qualifiedIdentObject(selector.X)
						if obj != nil {
							if strings.HasSuffix(obj.Type().String(), "ZiplineTemplate") {
								expand = true
								r.expand(b, buf)
							}
						}
					}
				}
				if !expand {
					printer.Fprint(buf.buf, fset, fstmt)
					buf.ws("\n")
				}
			default:
				printer.Fprint(buf.buf, fset, fstmt)
				buf.ws("\n")
			}
		}
		buf.ws("}\n")
		buf.ws("}\n\n")
	}

	return buf.buf.Bytes(), nil
}

func (r *renderer) expand(b *binding, buf buffer) {
	params := []string{}
	for _, p := range b.handler.params {
		ft := r.provider.provide(p)
		if ft != nil {
			buf.ws("%s\n\n", ft.call())
		} else if pathParam(b, p) {
			buf.ws(p.name + ", err := strconv.Atoi(chi.URLParam(" + HREQ.varName() + ", \"" + p.name + "\"))\n")
			buf.ws("if err != nil {\n")
			buf.ws("  // invalid request error\n")
			buf.ws("  http.Error(responseWriter, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n")
			buf.ws("  return\n")
			buf.ws("}\n\n")
		} else if b.method == "Post" || b.method == "Put" {
			buf.ws(p.varName() + " := " + p.inst() + "\n")
			buf.ws("err = json.NewDecoder(" + HREQ.varName() + ".Body).Decode(" + p.varNameAsPointer() + ")\n")
			buf.ws("if err != nil {\n")
			buf.ws("  // invalid request error\n")
			buf.ws("  http.Error(responseWriter, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n")
			buf.ws("  return\n")
			buf.ws("}\n\n")
		}

		params = append(params, p.varName())

		r.imp(p.pkg())

		buf.ws("\n")
	}

	if b.handler.x != nil {
		xp := r.provider.provide(b.handler.x)
		buf.ws(xp.call() + "\n\n")
		r.imp(xp.pkg())

		funk, ok := r.provider.varFor(b.handler.x)
		if !ok {
			panic("Dependencies not satisfied")
		}

		buf.ws("response, err := " + funk.varName() + "." + b.handler.sel + "(" + strings.Join(params, ",") + ")\n")
	} else {
		buf.ws("response, err := " + b.handler.sel + "(" + strings.Join(params, ",") + ")\n")
	}
}

func join(tokens []*varToken) string {
	s := []string{}
	for _, token := range tokens {
		s = append(s, token.param())
	}

	return strings.Join(s, ",")
}
