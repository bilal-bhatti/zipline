package internal

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"log"
	"strings"

	"github.com/go-toolsmith/astcopy"
	"golang.org/x/tools/go/packages"
)

type renderer struct {
	templates map[string]*template
	provider  *provider
	imps      []string
	preamble  buffer
	body      buffer
}

func (r *renderer) imp(imp string) {
	if imp != "" {
		r.imps = append(r.imps, "\""+imp+"\"")
	}
}

func newRenderer(templates map[string]*template, provider *provider) *renderer {
	r := &renderer{
		templates: templates,
		provider:  provider,
		imps:      make([]string, 0),
		preamble:  newBuffer(),
		body:      newBuffer(),
	}

	return r
}

func (r *renderer) render(pkg *packages.Package, info *binding) {
	template := r.templates[info.template]
	if template != nil {
		bites, err := r.renderTemplate(pkg, template, info)
		if err != nil {
			panic(err)
		}
		r.body.buf.Write(bites)
	} else {
		log.Println("Template not found for", info.template)
	}
}

func pkgName(packet *packet) string {
	pkn := packet.pkg.Name
	idx := strings.LastIndex(pkn, "/")
	if idx > 0 {
		pkn = pkn[:len(pkn)]
		return pkn
	}
	return pkn
}

func (r *renderer) complete(packet *packet) {
	r.preamble.ws("// Code generated by Zipline. DO NOT EDIT.\n\n")

	r.preamble.ws("//go:generate zipline\n")
	r.preamble.ws("//+build !ziplinegen\n\n")

	// write package name
	r.preamble.ws("package %s\n\n", pkgName(packet))

	// write imports
	r.preamble.ws("import (\n%s)\n\n", strings.Join(r.imps, "\n"))

	// write binding func
	fset := token.NewFileSet()
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, packet.funcDecl)
	r.preamble.ws("\n\n")
	r.preamble.buf.Write(buf.Bytes())
	r.preamble.ws("\n\n")

	// write generated handler funcs
	r.preamble.buf.Write(r.body.buf.Bytes())
}

func (r *renderer) print(w io.Writer, frmt bool) {
	if frmt {
		formatted, err := format.Source(r.preamble.buf.Bytes())
		if err != nil {
			panic(err)
		}
		w.Write(formatted)
	} else {
		w.Write(r.preamble.buf.Bytes())
	}
}

func (r *renderer) renderTemplate(pkg *packages.Package, t *template, b *binding) ([]byte, error) {
	fset := token.NewFileSet()

	buf := newBuffer()

	for _, stmt := range t.funcDecl.Body.List {
		// must be a return statement
		ret := stmt.(*ast.ReturnStmt)

		funclit := ret.Results[0].(*ast.FuncLit)
		// parse funclit type to extract type tokens
		for _, param := range funclit.Type.Params.List {
			for _, pn := range param.Names {
				obj := r.provider.qualifiedIdentObject(pn)
				tt := newTypeToken("", obj.Type().String(), obj.Name())
				r.provider.known[tt.signature] = tt
			}
		}

		buf.ws("// %s%s handles requests to:\n", b.id(), t.funcSuffix())
		buf.ws("// path  : %s\n", b.path)
		buf.ws("// method: %s\n", strings.ToLower(b.template))
		buf.ws("func %s%s() %s {\n", b.id(), t.funcSuffix(), t.returnType())
		buf.ws("return ")
		printer.Fprint(buf.buf, fset, funclit.Type)
		buf.ws(" {\n")

		for _, fstmt := range funclit.Body.List {
			assnStmt, ok := fstmt.(*ast.AssignStmt)

			if !ok {
				printer.Fprint(buf.buf, fset, fstmt)
				buf.ws("\n")
				continue
			}

			if call, ok := assnStmt.Rhs[0].(*ast.CallExpr); ok {
				if selector, ok := call.Fun.(*ast.SelectorExpr); ok {
					obj := r.provider.qualifiedIdentObject(selector.X)
					if obj != nil && strings.HasSuffix(obj.Type().String(), ZiplineTemplate) {
						if selector.Sel.String() == ZiplineTemplateResolve {
							r.resolve(pkg, b, assnStmt, buf)
						} else {
							r.expand(pkg, b, assnStmt, buf)
						}

						continue
					}
				}
			}

			// assignment statement, let's record the declared types
			for _, lhs := range assnStmt.Lhs {
				if id, ok := lhs.(*ast.Ident); ok {
					obj := r.provider.qualifiedIdentObject(id)

					// this will keep the later declarations
					tt := newTypeToken("", obj.Type().String(), obj.Name())
					r.provider.known[tt.signature] = tt
				}
			}

			printer.Fprint(buf.buf, fset, fstmt)
			buf.ws("\n")
		}

		buf.ws("}\n")
		buf.ws("}\n\n")
	}

	return buf.buf.Bytes(), nil
}

func (r *renderer) resolve(pkg *packages.Package, b *binding, assn *ast.AssignStmt, buf buffer) {
	// resolve/print handler
	if b.handler.x != nil {
		rets := []string{}
		// extract return names from the marker call
		for _, lhs := range assn.Lhs {
			rets = append(rets, lhs.(*ast.Ident).String())
		}

		xp := r.provider.provideWithReturns(b.handler.x, rets)
		buf.ws("\n// initialize application handler\n")
		buf.ws(xp.call(pkg.PkgPath) + "\n")
		r.imp(xp.pkg())
	}
}

func (r *renderer) expand(pkg *packages.Package, b *binding, assn *ast.AssignStmt, buf buffer) {
	// resolve/print app handler dependencies and retain their var names
	params := r.deps(pkg, b, buf)

	rets := []string{}
	// extract return names from the marker call
	for _, lhs := range assn.Lhs {
		rets = append(rets, lhs.(*ast.Ident).String())
	}

	buf.ws("// execute application handler\n")

	buf.ws(strings.Join(rets, ","))
	buf.ws(" %s ", assn.Tok.String())

	if b.handler.x != nil {
		// a struct method is the handler
		funk, ok := r.provider.typeTokenFor(b.handler.x)
		if !ok {
			panic("Dependencies not satisfied")
		}

		buf.ws("%s.", funk.varName())
	}

	buf.ws("%s(%s)\n", b.handler.sel, strings.Join(params, ","))
}

func (r *renderer) deps(pkg *packages.Package, b *binding, buf buffer) []string {
	// TODO: remove the need for these
	// hreq, _ := r.provider.typeTokenFor(HREQ)
	// hwri, _ := r.provider.typeTokenFor(HWRI)

	params := []string{}
	for i := 0; i < len(b.handler.params); i++ {
		p := b.handler.params[i]

		if len(b.paramTemplates) > i {
			tn := b.paramTemplates[i]
			template := r.templates[tn]
			if template != nil {
				buf.ws("\n// parse %s parameter %s\n", tn, p.varName())
				switch tn {
				case "Query", "Path":
					r.renderParamTemplate(pkg, template, b, p, buf)
				case "Body":
					r.renderBodyTemplate(pkg, template, b, p, buf)
				default:
					panic(fmt.Sprintf("unknown template %s", tn))
				}

				params = append(params, p.varName())
				buf.ws("\n")
				continue
			}
		}

		if ft := r.provider.provide(p); ft != nil {
			buf.ws("\n// resolve %s dependency through a provider\n", p.varName())

			buf.ws("%s\n\n", ft.call(pkg.PkgPath))
			// } else if b.template == "Post" || b.template == "Put" {
			// 	buf.ws("\n// extract json body and marshall %s\n", p.varName())

			// 	buf.ws("%s := %s\n", p.varName(), p.inst())
			// 	buf.ws("err = json.NewDecoder(%s.Body).Decode(%s)\n", hreq.varName(), p.varNameAsPointer())
			// 	buf.ws("if err != nil {\n")
			// 	buf.ws("  // invalid request error\n")
			// 	buf.ws("  http.Error(%s, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n", hwri.varName())
			// 	buf.ws("  return\n")
			// 	buf.ws("}\n\n")
		} else {
			panic("Unable to resolve type " + p.signature)
		}

		params = append(params, p.varName())

		r.imp(p.pkg())

		buf.ws("\n")
	}

	return params
}

func (r *renderer) renderParamTemplate(pkg *packages.Package, t *template, b *binding, p *typeToken, buf buffer) {
	var tmplBody []ast.Stmt

	if len(t.funcDecl.Body.List) != 1 {
		panic(fmt.Sprintf("template %s must contain a single switch statement", t.funcDecl.Name))
	}

	switchStmt, ok := t.funcDecl.Body.List[0].(*ast.SwitchStmt)
	if !ok {
		panic(fmt.Sprintf("template %s must contain a single switch statement", t.funcDecl.Name))
	}

	for _, sb := range switchStmt.Body.List {
		caseStmt, ok := sb.(*ast.CaseClause)
		if !ok {
			panic(fmt.Sprintf("template %s must contain a signle switch statement", t.funcDecl.Name))
		}

		for _, csl := range caseStmt.List {
			blit, ok := csl.(*ast.BasicLit)
			if !ok {
				continue
			}

			if blit.Value == fmt.Sprintf("\"%s\"", p.signature) {
				tmplBody = caseStmt.Body
				break
			}
		}
	}

	if tmplBody == nil {
		panic(fmt.Sprintf("template %s doesn't support type %s", t.funcDecl.Name, p.signature))
	}

	tbuf := r.rename("name", p, tmplBody)
	buf.buf.Write(tbuf.buf.Bytes())
}

func (r *renderer) renderBodyTemplate(pkg *packages.Package, t *template, b *binding, p *typeToken, buf buffer) {
	tbuf := r.rename("name", p, t.funcDecl.Body.List)
	buf.buf.Write(tbuf.buf.Bytes())
}

func (r *renderer) rename(old string, new *typeToken, body []ast.Stmt) *buffer {
	renamer := func(n ast.Node) bool {
		switch nt := n.(type) {
		case *ast.BasicLit:
			if nt.Value == fmt.Sprintf("\"%s\"", old) {
				nt.Value = fmt.Sprintf("\"%s\"", new.name)
			}
		case *ast.Ident:
			if nt.Name == old {
				nt.Name = new.name
			}
		case *ast.CallExpr:
			for i := 0; i < len(nt.Args); i++ {
				arg := nt.Args[i]
				if ue, ok := arg.(*ast.UnaryExpr); ok {
					if id, ok := ue.X.(*ast.Ident); ok {
						if id.Name == old {
							if new.isPtr {
								// param was declared as a pointer
								// replace unary expression with ident
								nt.Args[i] = ast.NewIdent(new.name)
							}
						}
					}
				}
			}
		}

		return true
	}

	buf := newBuffer()

	for _, stmt := range body {
		sc := astcopy.Stmt(stmt)

		switch st := stmt.(type) {
		case *ast.AssignStmt:
			if r.newStructValue(st) {
				// get new object
				buf.ws("%s := %s\n", new.varName(), new.inst())
				continue
			}
			ast.Inspect(sc, renamer)
		case *ast.ExprStmt:
			// filter out zipline directive
			if r.devNull(st) {
				continue
			}
			ast.Inspect(sc, renamer)
		default:
			ast.Inspect(sc, renamer)
		}

		printer.Fprint(buf.buf, token.NewFileSet(), sc)
		buf.ws("\n")
	}

	return &buf
}

func (r *renderer) devNull(expr *ast.ExprStmt) bool {
	if call, ok := expr.X.(*ast.CallExpr); ok {
		if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
			zobj := r.provider.qualifiedIdentObject(sel.X)
			if zobj != nil && strings.HasSuffix(zobj.Type().String(), ZiplineTemplate) {
				// if ignore
				if sel.Sel.Name == "DevNull" {
					return true
				}
			}
		}
	}
	return false
}

func (r *renderer) newStructValue(expr *ast.AssignStmt) bool {
	// check if it's a new ZiplineTemplate object
	// must be a simple assignment like
	// name := ZiplineTemplate{} or name := &ZiplineTemplate{}
	if len(expr.Lhs) != 1 && len(expr.Rhs) != 1 {
		return false
	}

	newObj, ok := expr.Rhs[0].(*ast.CompositeLit)
	if !ok {
		return false
	}

	valueType, ok := newObj.Type.(*ast.Ident)
	if !ok {
		return false
	}

	if valueType.Name != ZiplineTemplate {
		return false
	}

	return true
}

func join(tokens []*typeToken) string {
	s := []string{}
	for _, token := range tokens {
		s = append(s, token.param())
	}

	return strings.Join(s, ",")
}
