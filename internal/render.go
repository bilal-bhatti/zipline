package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"go/printer"
	"go/token"
	"io"
	"strings"
)

var (
	HREQ  = newVarToken("", "*net/http.Request", "request")
	HWRI  = newVarToken("", "net/http.ResponseWriter", "responseWriter")
	ERROR = newVarToken("", "error", "err")
)

type renderer struct {
	provider *provider
	imps     []string
	preamble *bytes.Buffer
	body     *bytes.Buffer
}

func (r *renderer) imp(imp string) {
	if imp != "" {
		r.imps = append(r.imps, "\""+imp+"\"")
	}
}

func newRenderer(provider *provider) *renderer {
	r := &renderer{
		provider: provider,
		imps:     make([]string, 0),
		preamble: &bytes.Buffer{},
		body:     &bytes.Buffer{},
	}

	return r
}

func (r *renderer) render(info *binding) {
	switch info.method {
	case "Post":
		r.post(info)
	case "Get":
		r.post(info)
	}
}

func (r *renderer) ws(s string, vals ...interface{}) {
	if len(vals) > 0 {
		r.body.WriteString(fmt.Sprintf(s, vals...))
	} else {
		r.body.WriteString(s)
	}
}

func (r *renderer) pre(s string, vals ...interface{}) {
	if len(vals) > 0 {
		r.preamble.WriteString(fmt.Sprintf(s, vals...))
	} else {
		r.preamble.WriteString(s)
	}
}

func pkgName(packet *packet) string {
	pkn := packet.pkg.Name
	idx := strings.LastIndex(pkn, "/")
	if idx > 0 {
		pkn = pkn[:len(pkn)]
		return pkn
	}
	return pkn
}

func (r *renderer) complete(packet *packet) {
	r.pre("// Code generated by Zipline. DO NOT EDIT.\n\n")

	r.pre("// go:generate zipline\n")
	r.pre("// +build !ziplinegen\n\n")

	// write package name
	r.pre("package %s\n\n", pkgName(packet))

	// write imports
	r.pre("import (\n%s)\n\n", strings.Join(r.imps, "\n"))

	// write binding func
	fset := token.NewFileSet()
	var buf bytes.Buffer
	printer.Fprint(&buf, fset, packet.bindings)
	r.pre("\n\n")
	r.preamble.Write(buf.Bytes())
	r.pre("\n\n")

	// write generated handler funcs
	r.preamble.Write(r.body.Bytes())
}

func (r *renderer) print(w io.Writer, frmt bool) {
	if frmt {
		formatted, err := format.Source(r.preamble.Bytes())
		if err != nil {
			panic(err)
		}
		w.Write(formatted)
	} else {
		w.Write(r.preamble.Bytes())
	}
}

func (r *renderer) post(binding *binding) {
	r.imp(HREQ.pkg())

	r.ws("func %sHandlerFunc() http.HandlerFunc {\n", binding.id())
	r.ws("return func(%s %s, %s %s) {\n", HWRI.varName(), HWRI.param(), HREQ.varName(), HREQ.param())
	r.ws("var err error // tempory fix\n\n")

	params := []string{}
	for _, p := range binding.handler.params {
		ft := r.provider.provide(p)
		if ft != nil {
			r.writeProvider(ft)
		} else if pathParam(binding, p) {
			r.writePathParam(p)
		} else if binding.method == "Post" {
			r.writeJSONDecoder(p)
		}

		params = append(params, p.varName())

		r.imp(p.pkg())

		r.ws("\n")
	}

	if binding.handler.x != nil {
		xp := r.provider.provide(binding.handler.x)
		r.writeProvider(xp)

		funk, ok := r.provider.varFor(binding.handler.x)
		if !ok {
			panic("Dependencies not satisfied")
		}

		r.ws("result, err := %s.%s(%s)\n", funk.varName(), binding.handler.sel, strings.Join(params, ","))
	} else {
		r.ws("result, err := %s(%s)\n", binding.handler.sel, strings.Join(params, ","))
	}

	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  // internal error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")

	r.ws("%s.WriteHeader(http.StatusOK)\n", HWRI.varName())
	r.ws("%s.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n", HWRI.varName())

	r.ws("err = json.NewEncoder(%s).Encode(result)\n", HWRI.varName())
	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  panic(err)\n")
	r.ws("}\n")

	r.ws("}\n")
	r.ws("}\n\n")
}

func (r *renderer) writeProvider(ft *funcToken) {
	r.ws("%s\n\n", ft.call())
	r.imp(ft.pkg())
}

func (r *renderer) writePathParam(p *varToken) {
	r.ws("%s, err := strconv.Atoi(chi.URLParam(%s, \"%s\"))\n", p.name, HREQ.varName(), p.name)
	r.ws("if err != nil {\n")
	r.ws("  // invalid request error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")
}

func (r *renderer) writeJSONDecoder(p *varToken) {
	r.ws("%s := %s\n", p.varName(), p.inst())
	r.ws("err = json.NewDecoder(%s.Body).Decode(%s)\n", HREQ.varName(), p.varNameAsPointer())
	r.ws("if err != nil {\n")
	r.ws("  // write error response\n")
	r.ws("  // invalid request error\n")
	r.ws("  panic(err)\n")
	r.ws("}\n\n")
}

// func (r *renderer) recordFuncType(b *binding) {
// 	tipe := fmt.Sprintf("%sType func(%s) (%s)", b.id(), join(b.handler.params), join(b.handler.returns))
// 	r.types = append(r.types, tipe)
// }

func join(tokens []*varToken) string {
	s := []string{}
	for _, token := range tokens {
		s = append(s, token.param())
	}

	return strings.Join(s, ",")
}
